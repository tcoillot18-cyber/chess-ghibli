<!doctype html>
<html lang="fr"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Chess Ghibli — Règles complètes</title>
<style>
:root{--sq:min(11vmin,12vw,8vh);--grid-line:rgba(255,255,255,.18);--grid-shadow:rgba(0,0,0,.12)}
*{box-sizing:border-box}html,body{height:100%}body{margin:0;font-family:ui-rounded,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:radial-gradient(110% 150% at 50% 0%,#0b1230 0%,#0a0f26 40%,#08102a 70%,#060c21 100%);color:#f3f4f6;overflow:hidden;touch-action:manipulation}
.app{height:100%;display:grid;grid-template-rows:auto 1fr auto;gap:12px;align-items:center;justify-items:center;padding:clamp(10px,2vmin,18px)}
header{display:flex;align-items:center;gap:10px;padding:8px 12px;background:rgba(10,17,40,.45);border:1px solid rgba(255,255,255,.06);border-radius:14px;backdrop-filter:blur(6px);flex-wrap:wrap}
button{cursor:pointer;border:none;padding:10px 12px;border-radius:12px;background:rgba(255,255,255,.12);color:#fff;font-weight:600}button:hover{background:rgba(255,255,255,.2)}
.toggle{display:inline-flex;gap:6px;align-items:center;background:rgba(255,255,255,.08);padding:6px;border-radius:12px}.toggle button{padding:8px 10px;border-radius:10px;background:transparent;opacity:.65}.toggle button.active{background:rgba(255,255,255,.18);opacity:1}
.wrap{position:relative;display:grid;place-items:center;padding:12px;border-radius:22px;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03));border:1px solid rgba(255,255,255,.06);box-shadow:0 40px 80px rgba(0,0,0,.35),0 8px 18px rgba(0,0,0,.35) inset}
.stage{position:relative;width: calc(var(--sq) * 8);height: calc(var(--sq) * 8);border-radius:18px;overflow:hidden;isolation:isolate;touch-action:none}
.bg{position:absolute;inset:0;background-image:url('assets/forest/forest-background-light.webp');background-size:cover;background-position:center;background-repeat:no-repeat;z-index:0}
.grid{position:absolute;inset:0;z-index:1;pointer-events:none;background:
linear-gradient(to right,var(--grid-line) 1px,transparent 1px) 0 0/ calc(100%/8) 100%,
linear-gradient(to bottom,var(--grid-line) 1px,transparent 1px) 0 0/ 100% calc(100%/8),
linear-gradient(to right,var(--grid-shadow) 1px,transparent 1px) 0 0/ calc(100%/8) 100%,
linear-gradient(to bottom,var(--grid-shadow) 1px,transparent 1px) 0 0/ 100% calc(100%/8);mix-blend-mode:soft-light}
.mask{position:absolute;inset:0;z-index:2;pointer-events:none;display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr)}.sq{opacity:.10}.sq.light{background:radial-gradient(160% 160% at 50% 50%,rgba(255,255,255,.60) 0%,rgba(255,255,255,0) 70%)}.sq.dark{background:radial-gradient(160% 160% at 50% 50%,rgba(0,0,0,.55) 0%,rgba(0,0,0,0) 70%)}
.board{position:absolute;inset:0;z-index:3;display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr)}
.cell{position:relative;display:grid;place-items:center}.piece{width:88%;height:88%;object-fit:contain;filter:drop-shadow(0 2px 0 rgba(0,0,0,.25)) drop-shadow(0 8px 12px rgba(0,0,0,.18));touch-action:none}
.hint{position:absolute;width:20%;height:20%;border-radius:999px;background:rgba(255,255,255,.95);box-shadow:0 0 0 6px rgba(0,0,0,.14) inset}.selected{outline:3px solid #d1a325;border-radius:10px}
.dragGhost{position:fixed;left:0;top:0;width:min(12vmin,80px);height:min(12vmin,80px);pointer-events:none;z-index:9999;transform:translate(-50%,-50%);filter:drop-shadow(0 8px 16px rgba(0,0,0,.35))}
.status{font-size:14px;opacity:.9;padding:6px 10px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.1);border-radius:10px}
footer{opacity:.85;font-size:12px}
</style></head>
<body>
<div class="app">
<header><span>♟️ Chess Ghibli — Règles complètes</span>
<button id="btnNew">Rejouer</button><button id="btnFlip">Flip</button>
<div class="toggle"><button id="modeClick" class="active">Cliquer</button><button id="modeDrag">Drag & Drop</button></div>
<div class="status" id="status">Au trait : Blancs</div></header>
<div class="wrap"><div class="stage" id="stage">
<div class="bg"></div><div class="grid"></div><div class="mask" id="mask"></div><div class="board" id="board"></div></div></div>
<footer>Roque, en passant, promotion, échec & mat. Ajoute ?v=cache après mise à jour.</footer>
</div>
<script>
const FILES=['a','b','c','d','e','f','g','h'],RANKS=['1','2','3','4','5','6','7','8'];
const EMPTY=null;const W='w',B='b';
const sq=(f,r)=>FILES[f]+RANKS[r];const pos=s=>({f:s.charCodeAt(0)-97,r:s.charCodeAt(1)-49});const inb=(f,r)=>f>=0&&f<8&&r>=0&&r<8;
const deep=a=>JSON.parse(JSON.stringify(a));
function start(){const e=EMPTY,P=t=>c=>({type:t,color:c});return{board:[
[P('r')(B),P('n')(B),P('b')(B),P('q')(B),P('k')(B),P('b')(B),P('n')(B),P('r')(B)],
[P('p')(B),P('p')(B),P('p')(B),P('p')(B),P('p')(B),P('p')(B),P('p')(B),P('p')(B)],
[e,e,e,e,e,e,e,e],[e,e,e,e,e,e,e,e],[e,e,e,e,e,e,e,e],[e,e,e,e,e,e,e,e],
[P('p')(W),P('p')(W),P('p')(W),P('p')(W),P('p')(W),P('p')(W),P('p')(W),P('p')(W)],
[P('r')(W),P('n')(W),P('b')(W),P('q')(W),P('k')(W),P('b')(W),P('n')(W),P('r')(W)]],
turn:W,castling:{w:{K:true,Q:true},b:{K:true,Q:true}},ep:null,half:0,full:1};}
function get(st,s){const {f,r}=pos(s);return st.board[7-r][f]}function set(st,s,v){const {f,r}=pos(s);st.board[7-r][f]=v}
function kingSq(st,c){for(let r=0;r<8;r++)for(let f=0;f<8;f++){const p=st.board[r][f];if(p&&p.type==='k'&&p.color===c)return sq(f,7-r)}return null}
function pseudoFromSq(st,from){const p=get(st,from);if(!p)return[];const res=[];const {f,r}=pos(from);const add=(to,spec)=>{const t=get(st,to);if(!t||t.color!==p.color)res.push({from,to,piece:p.type,special:spec})}
if(p.type==='p'){const dir=p.color===W?1:-1;const startR=p.color===W?1:6;let nf=f,nr=r+dir,to=sq(nf,nr);if(inb(nf,nr)&&!get(st,to)){add(to);if(r===startR){nr=r+2*dir;to=sq(nf,nr);if(!get(st,to))add(to,{double:true})}}for(const df of[-1,1]){nf=f+df;nr=r+dir;to=sq(nf,nr);if(inb(nf,nr)){const t=get(st,to);if(t&&t.color!==p.color)add(to)}}if(st.ep){const ep=pos(st.ep);if(Math.abs(ep.f-f)===1&&ep.r===r+dir)add(st.ep,{enpassant:true})}}
else if(p.type==='n'){const J=[[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];for(const[dF,dR]of J){const nf=f+dF,nr=r+dR;if(inb(nf,nr))add(sq(nf,nr))}}
else if(p.type==='k'){for(let df=-1;df<=1;df++)for(let dr=-1;dr<=1;dr++){if(!df&&!dr)continue;const nf=f+df,nr=r+dr;if(inb(nf,nr))add(sq(nf,nr))}if(!attacksSquare(st,p.color===W?B:W,from)){const rank=(p.color===W)?0:7;if(st.castling[p.color].K){const t1=sq(5,rank),t2=sq(6,rank);if(!get(st,t1)&&!get(st,t2)&&!attacksSquare(st,p.color===W?B:W,t1)&&!attacksSquare(st,p.color===W?B:W,t2))add(t2,{castle:'K'})}
if(st.castling[p.color].Q){const t1=sq(3,rank),t2=sq(2,rank),t3=sq(1,rank);if(!get(st,t1)&&!get(st,t2)&&!get(st,t3)&&!attacksSquare(st,p.color===W?B:W,t1)&&!attacksSquare(st,p.color===W?B:W,t2))add(t2,{castle:'Q'})}}}
else{const dirs=[];if(p.type==='b'||p.type==='q')dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);if(p.type==='r'||p.type==='q')dirs.push([1,0],[-1,0],[0,1],[0,-1]);for(const[dF,dR]of dirs){let nf=f+dF,nr=r+dR;while(inb(nf,nr)){const to=sq(nf,nr),t=get(st,to);add(to);if(t)break;nf+=dF;nr+=dR}}}return res}
function pseudoFromColor(st,color){const m=[];for(let r=0;r<8;r++)for(let f=0;f<8;f++){const p=st.board[r][f];if(p&&p.color===color){m.push(...pseudoFromSq(st,sq(f,7-r)))}}return m}
function attacksSquare(st,color,target){const m=pseudoFromColor(st,color);return m.some(x=>x.to===target)}
function makeMove(st,m){const S=deep(st);const p=get(S,m.from);if(m.special&&m.special.enpassant){const {f,r}=pos(m.to);const dir=p.color===W?-1:1;set(S,sq(f,r+dir),EMPTY)}if(m.special&&m.special.castle){const side=p.color,rank=(side===W)?0:7;if(m.special.castle==='K'){const rf=sq(7,rank),rt=sq(5,rank);const rook=get(S,rf);set(S,rf,EMPTY);set(S,rt,rook)}else{const rf=sq(0,rank),rt=sq(3,rank);const rook=get(S,rf);set(S,rf,EMPTY);set(S,rt,rook)}}set(S,m.from,EMPTY);set(S,m.to,{type:p.type,color:p.color});if(m.promotion){set(S,m.to,{type:m.promotion,color:p.color})}else if(p.type==='p'){const rr=pos(m.to).r;if((p.color===W&&rr===7)||(p.color===B&&rr===0))set(S,m.to,{type:'q',color:p.color})}
function touch(fromSq,p){const side=p.color,rank=(side===W)?'1':'8';if(p.type==='k'){S.castling[side].K=false;S.castling[side].Q=false}else if(p.type==='r'){if(fromSq==='h'+rank)S.castling[side].K=false;if(fromSq==='a'+rank)S.castling[side].Q=false}}touch(m.from,p);if(m.captured){const to=m.to;if(to==='h1')S.castling.w.K=false;if(to==='a1')S.castling.w.Q=false;if(to==='h8')S.castling.b.K=false;if(to==='a8')S.castling.b.Q=false}
S.ep=null;if(p.type==='p'&&m.special&&m.special.double){const f=pos(m.from),t=pos(m.to);S.ep=sq(f.f,(f.r+t.r)/2)}S.turn=(S.turn===W)?B:W;if(S.turn===W)S.full++;return S}
function isInCheck(st,color){const k=kingSq(st,color);const opp=color===W?B:W;return attacksSquare(st,opp,k)}
function legalFromSq(st,from){const p=get(st,from);if(!p||p.color!==st.turn)return[];const pseudo=pseudoFromSq(st,from);const out=[];for(const m of pseudo){const tmp=deep(st);m.captured=get(tmp,m.to)?.type||(m.special&&m.special.enpassant?'p':undefined);const after=makeMove(tmp,m);if(!isInCheck(after,p.color))out.push(m)}return out}
function allLegal(st){const res=[];for(let r=0;r<8;r++)for(let f=0;f<8;f++){const p=st.board[r][f];if(p&&p.color===st.turn){res.push(...legalFromSq(st,sq(f,7-r)))}}return res}
function Chess(){let st=start();return{reset(){st=start()},board(){return st.board.map(row=>row.map(p=>p?{type:p.type,color:p.color}:null))},turn(){return st.turn},state(){return deep(st)},get(s){return get(st,s)},moves(o){if(!o||!o.square)return[];return legalFromSq(st,o.square).map(m=>({from:m.from,to:m.to,special:m.special}))},allMoves(){return allLegal(st)},inCheck(c){return isInCheck(st,c)},move(m){const legal=legalFromSq(st,m.from).find(x=>x.to===m.to);if(!legal)return null;const P=get(st,m.from);if(P.type==='p'){const toR=pos(m.to).r;if((P.color===W&&toR===7)||(P.color===B&&toR===0))legal.promotion=m.promotion||'q'}st=makeMove(st,legal);const l=allLegal(st);const chk=isInCheck(st,st.turn);let outcome=null;if(l.length===0){outcome=chk?{type:'checkmate',winner:st.turn===W?B:W}:{type:'stalemate'}}return{ok:true,outcome}}}}
window.Chess=Chess;
// UI
(function(){
const files=FILES,ranks=RANKS;let orientation='white';const game=new window.Chess();
const boardEl=document.getElementById('board'),mask=document.getElementById('mask'),btnNew=document.getElementById('btnNew'),btnFlip=document.getElementById('btnFlip'),modeClickBtn=document.getElementById('modeClick'),modeDragBtn=document.getElementById('modeDrag'),statusEl=document.getElementById('status');
let interactionMode='click';
const mapWhite={k:'king-cat.webp',q:'queen-frog.webp',b:'bishop-owl.webp',n:'knight-deer.webp',r:'rook-bear.webp',p:'pawn-mouse.webp'};
const mapBlack={k:'king-cat.webp',q:'queen-frog.webp',b:'bishop-owl.webp',n:'knight-deer.webp',r:'rook-bear.webp',p:'pawn-mouse.webp'};
const assetPath=(color,type)=>`assets/pieces/${color==='w'?'white':'black'}/${(color==='w'?mapWhite:mapBlack)[type]}`;
const isLight=sq=>{const f=sq.charCodeAt(0)-97,r=sq.charCodeAt(1)-49;return((f+r)%2)===1}
function renderMask(){mask.innerHTML='';const squares=[];for(let r=7;r>=0;r--)for(let f=0;f<8;f++)squares.push(files[f]+ranks[r]);const order=(orientation==='black')?squares.slice().reverse():squares;order.forEach(s=>{const d=document.createElement('div');d.className='sq '+(isLight(s)?'light':'dark');mask.appendChild(d)})}
function squares(){const L=[];for(let r=7;r>=0;r--)for(let f=0;f<8;f++)L.push(files[f]+ranks[r]);return(orientation==='black')?L.reverse():L}
function pieceAt(state,s){const f=files.indexOf(s[0]),r=ranks.indexOf(s[1]);return state[7-r]?.[f]||null}
function updateStatus(){const st=game.state();let txt=`Au trait : ${st.turn==='w'?'Blancs':'Noirs'}`;const legal=game.allMoves();if(legal.length===0){if(game.inCheck(st.turn))txt=`Échec et mat — ${st.turn==='w'?'Noirs':'Blancs'} gagnent`;else txt='Pat — partie nulle'}else if(game.inCheck(st.turn)){txt+=' — Échec !'}statusEl.textContent=txt}
function render(){boardEl.innerHTML='';const order=squares(),state=game.board();order.forEach(s=>{const cell=document.createElement('div');cell.className='cell';cell.dataset.square=s;const p=pieceAt(state,s);if(p){const img=new Image();img.className='piece';img.src=assetPath(p.color,p.type);img.alt=(p.color==='w'?'White ':'Black ')+p.type;img.dataset.square=s;cell.appendChild(img);if(interactionMode==='drag'){img.style.cursor='grab';img.addEventListener('pointerdown',ev=>onDragStart(ev,s),{passive:false})}else{img.style.cursor='pointer'}}if(interactionMode==='click'){cell.addEventListener('click',onCellClick,{passive:true})}boardEl.appendChild(cell)});renderMask();updateStatus()}
let selected=null,legalMoves=[];function clearHi(){document.querySelectorAll('.cell').forEach(s=>s.classList.remove('selected'));document.querySelectorAll('.cell .hint').forEach(h=>h.remove())}
function showHints(){legalMoves.forEach(m=>{const el=document.querySelector('.cell[data-square="'+m.to+'"]');if(el){const dot=document.createElement('div');dot.className='hint';el.appendChild(dot)}})}
function onCellClick(e){const s=e.currentTarget.dataset.square,p=game.get(s),own=p&&p.color===game.state().turn;if(selected){const L=legalMoves.find(m=>m.to===s);if(L){game.move({from:selected,to:s,promotion:'q'});selected=null;legalMoves=[];clearHi();render();return}if(own){selected=s;legalMoves=game.moves({square:s});clearHi();document.querySelector('.cell[data-square="'+s+'"]').classList.add('selected');showHints()}else{selected=null;legalMoves=[];clearHi()}return}
if(own){selected=s;legalMoves=game.moves({square:s});clearHi();document.querySelector('.cell[data-square="'+s+'"]').classList.add('selected');showHints()}} 
let drag={active:false,from:null,ghost:null,moves:[]};function onDragStart(ev,s){ev.preventDefault();const p=game.get(s);if(!p||p.color!==game.state().turn)return;drag.active=true;drag.from=s;drag.moves=game.moves({square:s});clearHi();const fromEl=document.querySelector('.cell[data-square="'+s+'"]');if(fromEl)fromEl.classList.add('selected');showHints();const img=ev.currentTarget,g=img.cloneNode(true);g.classList.add('dragGhost');document.body.appendChild(g);drag.ghost=g;moveGhost(ev.clientX,ev.clientY);img.setPointerCapture?.(ev.pointerId);window.addEventListener('pointermove',onDragMove,{passive:false});window.addEventListener('pointerup',onDragEnd,{passive:false})}
function moveGhost(x,y){if(!drag.ghost)return;drag.ghost.style.left=x+'px';drag.ghost.style.top=y+'px'}
function onDragMove(ev){ev.preventDefault();moveGhost(ev.clientX,ev.clientY)}
function onDragEnd(ev){ev.preventDefault();window.removeEventListener('pointermove',onDragMove);window.removeEventListener('pointerup',onDragEnd);if(!drag.active)return;const el=document.elementFromPoint(ev.clientX,ev.clientY);const cell=el&&el.closest?el.closest('.cell'):null;const to=cell?cell.dataset.square:null;const L=drag.moves.find(m=>m.to===to);if(L)game.move({from:drag.from,to:to,promotion:'q'});drag={active:false,from:null,ghost:drag.ghost?drag.ghost.parentNode.removeChild(drag.ghost):null,moves:[]};clearHi();render()}
document.getElementById('btnNew').addEventListener('click',()=>{game.reset();selected=null;legalMoves=[];clearHi();render()});
document.getElementById('btnFlip').addEventListener('click',()=>{orientation=(orientation==='white')?'black':'white';selected=null;legalMoves=[];clearHi();render()});
document.getElementById('modeClick').addEventListener('click',()=>{interactionMode='click';modeClick.classList.add('active');modeDrag.classList.remove('active');render()});
document.getElementById('modeDrag').addEventListener('click',()=>{interactionMode='drag';modeDrag.classList.add('active');modeClick.classList.remove('active');render()});
render();
})();</script></body></html>