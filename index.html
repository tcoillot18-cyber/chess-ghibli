<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Chess Ghibli — Overlay Fix</title>
<style>
  :root{ --sq:min(11vmin,12vw,8vh); --grid:rgba(255,255,255,.22); --maskL:rgba(255,255,255,.30); --maskD:rgba(0,0,0,.30); }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:#0b1229;color:#f3f4f6;font-family:system-ui,Segoe UI,Roboto,sans-serif;overflow:hidden}
  .app{height:100%;display:grid;grid-template-rows:auto 1fr auto;gap:12px;align-items:center;justify-items:center;padding:clamp(10px,2vmin,18px)}
  header{display:flex;gap:10px;align-items:center;background:#ffffff10;border:1px solid #ffffff1a;border-radius:14px;padding:8px 12px;flex-wrap:wrap}
  button{border:0;border-radius:12px;background:#ffffff22;color:#fff;padding:8px 12px;font-weight:600;cursor:pointer}
  button:hover{background:#ffffff33}
  .stageWrap{position:relative;display:grid;place-items:center;padding:12px;border-radius:22px;background:#ffffff0a;border:1px solid #ffffff14;box-shadow:0 30px 60px #0007 inset}
  .stage{position:relative;width:calc(var(--sq)*8);height:calc(var(--sq)*8);border-radius:18px;overflow:hidden;isolation:isolate}
  .bg{position:absolute;inset:0;background:url('assets/forest/forest-background-light.webp') center/cover no-repeat;filter:saturate(1) contrast(1.02)}
  /* TRUE grid overlay (fixed to 8x8), independent of background */
  .grid{position:absolute;inset:0;z-index:2;pointer-events:none;
        background:
          linear-gradient(to right,var(--grid) 1px,transparent 1px) 0 0/ calc(100%/8) 100%,
          linear-gradient(to bottom,var(--grid) 1px,transparent 1px) 0 0/ 100% calc(100%/8);}
  /* Light/Dark mask for readability over any background */
  .mask{position:absolute;inset:0;z-index:1;display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);pointer-events:none}
  .sq{opacity:.18}
  .sq.light{background:radial-gradient(160% 160% at 50% 50%,var(--maskL) 0%,transparent 70%)}
  .sq.dark{ background:radial-gradient(160% 160% at 50% 50%,var(--maskD) 0%,transparent 70%)}
  /* Cells layer for pieces */
  .board{position:absolute;inset:0;z-index:3;display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr)}
  .cell{position:relative;display:grid;place-items:center}
  .piece{width:88%;height:88%;object-fit:contain;filter:drop-shadow(0 1px 0 #0006) drop-shadow(0 10px 12px #0006);touch-action:none}
  .hint{position:absolute;width:24%;height:24%;border-radius:999px;background:#fff;opacity:.92;box-shadow:0 0 0 6px #0003 inset}
  .selected{outline:3px solid #d1a325;border-radius:12px}
  .status{font-size:14px;background:#ffffff12;border:1px solid #ffffff22;border-radius:10px;padding:6px 10px}
</style>
</head>
<body>
<div class="app">
  <header>
    <strong>♟️ Chess Ghibli — Overlay Fix</strong>
    <button id="btnNew">Rejouer</button>
    <button id="btnFlip">Flip</button>
    <button id="btnMode">Mode: Clic</button>
    <div class="status" id="status">Initialisation…</div>
  </header>
  <div class="stageWrap">
    <div class="stage">
      <div class="bg"></div>
      <div class="mask" id="mask"></div>
      <div class="grid"></div>
      <div class="board" id="board"></div>
    </div>
  </div>
  <footer>Règles complètes — roque, en passant, promotion, échec/mat. L’overlay assure l’alignement.</footer>
</div>

<script>
/*** ------- Engine (full rules) ------- ***/
const F=['a','b','c','d','e','f','g','h'], R=['1','2','3','4','5','6','7','8'], W='w', B='b', E=null;
const sq=(f,r)=>F[f]+R[r], pos=s=>({f:s.charCodeAt(0)-97, r:s.charCodeAt(1)-49}), inb=(f,r)=>f>=0&&f<8&&r>=0&&r<8, cl=o=>JSON.parse(JSON.stringify(o));
function start(){ const e=E, P=t=>c=>({type:t,color:c});
  return {board:[[P('r')(B),P('n')(B),P('b')(B),P('q')(B),P('k')(B),P('b')(B),P('n')(B),P('r')(B)],
                 [P('p')(B),P('p')(B),P('p')(B),P('p')(B),P('p')(B),P('p')(B),P('p')(B),P('p')(B)],
                 [e,e,e,e,e,e,e,e],[e,e,e,e,e,e,e,e],[e,e,e,e,e,e,e,e],[e,e,e,e,e,e,e,e],
                 [P('p')(W),P('p')(W),P('p')(W),P('p')(W),P('p')(W),P('p')(W),P('p')(W),P('p')(W)],
                 [P('r')(W),P('n')(W),P('b')(W),P('q')(W),P('k')(W),P('b')(W),P('n')(W),P('r')(W)]],
          turn:W, castling:{w:{K:true,Q:true}, b:{K:true,Q:true}}, ep:null, half:0, full:1};
}
function get(st,s){const {f,r}=pos(s);return st.board[7-r][f]}
function set(st,sq,v){const{f,r}=pos(sq);st.board[7-r][f]=v}
function ksq(st,c){for(let r=0;r<8;r++)for(let f=0;f<8;f++){const p=st.board[r][f];if(p&&p.type==='k'&&p.color===c)return sq(f,7-r)}return null}
function dirs(t){const d=[];if(t==='b'||t==='q')d.push([1,1],[1,-1],[-1,1],[-1,-1]);if(t==='r'||t==='q')d.push([1,0],[-1,0],[0,1],[0,-1]);return d}
function psColor(st,c){const m=[];for(let r=0;r<8;r++)for(let f=0;f<8;f++){const p=st.board[r][f];if(p&&p.color===c)m.push(...psSquare(st,sq(f,7-r)))}return m}
function attacks(st,byColor,target){return psColor(st,byColor).some(m=>m.to===target)}
function psSquare(st,from){const p=get(st,from);if(!p)return[];const res=[];const{f,r}=pos(from);
  const add=(to,spec)=>{const t=get(st,to);if(!t||t.color!==p.color)res.push({from,to,piece:p.type,spec})}
  if(p.type==='p'){const dir=p.color===W?1:-1;const sr=p.color===W?1:6;let nf=f,nr=r+dir,to=sq(nf,nr);
    if(inb(nf,nr)&&!get(st,to)){add(to);if(r===sr){nr=r+2*dir;to=sq(nf,nr);if(!get(st,to))add(to,{double:true})}}
    for(const df of[-1,1]){nf=f+df;nr=r+dir;if(inb(nf,nr)){to=sq(nf,nr);const t=get(st,to);if(t&&t.color!==p.color)add(to)}}
    if(st.ep){const ep=pos(st.ep);if(Math.abs(ep.f-f)===1&&ep.r===r+dir)add(st.ep,{enpassant:true})}}
  else if(p.type==='n'){const J=[[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];for(const[dF,dR] of J){const nf=f+dF,nr=r+dR;if(inb(nf,nr))add(sq(nf,nr))}}
  else if(p.type==='k'){for(let df=-1;df<=1;df++)for(let dr=-1;dr<=1;dr++){if(!df&&!dr)continue;const nf=f+df,nr=r+dr;if(inb(nf,nr))add(sq(nf,nr))}
    const side=p.color, rank=(side===W)?0:7, opp=(side===W)?B:W;
    if(!attacks(st,opp,from)){
      if(st.castling[side].K){const t1=sq(5,rank),t2=sq(6,rank); if(!get(st,t1)&&!get(st,t2)&&!attacks(st,opp,t1)&&!attacks(st,opp,t2)) add(t2,{castle:'K'})}
      if(st.castling[side].Q){const c1=sq(3,rank),c2=sq(2,rank),c3=sq(1,rank); if(!get(st,c1)&&!get(st,c2)&&!get(st,c3)&&!attacks(st,opp,c1)&&!attacks(st,opp,c2)) add(c2,{castle:'Q'})}
    }}
  else{for(const[dF,dR] of dirs(p.type)){let nf=f+dF,nr=r+dR;while(inb(nf,nr)){const to=sq(nf,nr),t=get(st,to);add(to);if(t)break;nf+=dF;nr+=dR}}}
  return res;
}
function make(st,m){const S=cl(st);const p=get(S,m.from);
  if(m.spec&&m.spec.enpassant){const {f,r}=pos(m.to);const dir=p.color===W?-1:1;set(S,sq(f,r+dir),E)}
  if(m.spec&&m.spec.castle){const rk=(p.color===W)?0:7;if(m.spec.castle==='K'){const rf=sq(7,rk),rt=sq(5,rk);const rook=get(S,rf);set(S,rf,E);set(S,rt,rook)}else{const rf=sq(0,rk),rt=sq(3,rk);const rook=get(S,rf);set(S,rf,E);set(S,rt,rook)}}
  const captured=get(S,m.to); set(S,m.from,E); set(S,m.to,{type:p.type,color:p.color});
  const toR=pos(m.to).r; if(p.type==='p'&&(toR===7||toR===0)) set(S,m.to,{type:m.promotion||'q',color:p.color});
  function touch(fromSq,piece){const side=piece.color,rk=(side===W)?'1':'8'; if(piece.type==='k'){S.castling[side].K=false;S.castling[side].Q=false}
    else if(piece.type==='r'){if(fromSq==='h'+rk)S.castling[side].K=false;if(fromSq==='a'+rk)S.castling[side].Q=false}}
  touch(m.from,p); if(captured){const t=m.to; if(t==='h1')S.castling.w.K=false; if(t==='a1')S.castling.w.Q=false; if(t==='h8')S.castling.b.K=false; if(t==='a8')S.castling.b.Q=false}
  S.ep=null; if(p.type==='p'&&m.spec&&m.spec.double){const f=pos(m.from),t=pos(m.to); S.ep=sq(f.f,(f.r+t.r)/2)}
  S.turn=(S.turn===W)?B:W; if(S.turn===W)S.full++; return S;
}
function inCheck(st,c){const ks=ksq(st,c);const opp=(c===W)?B:W;return attacks(st,opp,ks)}
function legalFrom(st,from){const p=get(st,from);if(!p||p.color!==st.turn)return[];const ps=psSquare(st,from),out=[];for(const m of ps){const tmp=cl(st);m.captured=get(tmp,m.to)?.type||(m.spec&&m.spec.enpassant?'p':undefined);const after=make(tmp,m);if(!inCheck(after,p.color))out.push(m)}return out}
function allLegal(st){const L=[];for(let r=0;r<8;r++)for(let f=0;f<8;f++){const p=st.board[r][f];if(p&&p.color===st.turn)L.push(...legalFrom(st,sq(f,7-r)))}return L}
function outcome(st){const L=allLegal(st),chk=inCheck(st,st.turn);if(L.length===0){if(chk)return{type:'checkmate',winner:(st.turn===W?B:W)};return{type:'stalemate'}}return null}
function Game(){let st=start();return{
  reset(){st=start()}, state(){return cl(st)}, board(){return st.board.map(r=>r.map(p=>p?{type:p.type,color:p.color}:null))}, get(s){return get(st,s)},
  moves(o){if(!o||!o.square)return[];return legalFrom(st,o.square).map(m=>({from:m.from,to:m.to,spec:m.spec}))},
  all(){return allLegal(st)}, inCheck(c){return inCheck(st,c)}, move(m){const L=legalFrom(st,m.from).find(x=>x.to===m.to);if(!L)return null;
    const P=get(st,m.from);const toR=pos(m.to).r;if(P.type==='p'&&(toR===7||toR===0))L.promotion=m.promotion||'q'; st=make(st,L); return {ok:true,outcome:outcome(st)};}
}}

/*** ------- UI ------- ***/
const files=F,ranks=R; let orientation='white';
const game=new Game(); const board=document.getElementById('board'); const mask=document.getElementById('mask'); const status=document.getElementById('status');
let mode='click'; const btnMode=document.getElementById('btnMode');
const mapW={k:'king-cat.webp',q:'queen-frog.webp',b:'bishop-owl.webp',n:'knight-deer.webp',r:'rook-bear.webp',p:'pawn-mouse.webp'};
const mapB={k:'king-cat.webp',q:'queen-frog.webp',b:'bishop-owl.webp',n:'knight-deer.webp',r:'rook-bear.webp',p:'pawn-mouse.webp'};
const asset=(c,t)=>`assets/pieces/${c==='w'?'white':'black'}/${(c==='w'?mapW:mapB)[t]}`;
function isLight(S){const f=S.charCodeAt(0)-97,r=S.charCodeAt(1)-49;return((f+r)%2)===1}
function order(){const a=[];for(let r=7;r>=0;r--)for(let f=0;f<8;f++)a.push(files[f]+ranks[r]);return(orientation==='black')?a.reverse():a}
function pieceAt(bs,S){const f=files.indexOf(S[0]),r=ranks.indexOf(S[1]);return bs[7-r]?.[f]||null}

function renderMask(){ mask.innerHTML=''; for(const S of order()){ const d=document.createElement('div'); d.className='sq '+(isLight(S)?'light':'dark'); mask.appendChild(d); }}

function render(){
  board.innerHTML='';
  const bs=game.board();
  for(const S of order()){
    const cell=document.createElement('div'); cell.className='cell'; cell.dataset.square=S;
    const P=pieceAt(bs,S);
    if(P){
      const img=new Image(); img.className='piece'; img.alt=(P.color==='w'?'White ':'Black ')+P.type; img.src=asset(P.color,P.type); img.dataset.square=S;
      cell.appendChild(img);
      if(mode==='drag'){ img.style.cursor='grab'; img.addEventListener('pointerdown',ev=>onDragStart(ev,S),{passive:false}); }
    }
    if(mode==='click'){ cell.addEventListener('click', onCellClick, {passive:true}); }
    board.appendChild(cell);
  }
  renderMask(); updateStatus();
}

let selected=null, legal=[];
function clearHL(){ document.querySelectorAll('.cell').forEach(c=>c.classList.remove('selected')); document.querySelectorAll('.cell .hint').forEach(h=>h.remove()); }
function hints(){ legal.forEach(m=>{ const el=document.querySelector('.cell[data-square="'+m.to+'"]'); if(!el) return; const d=document.createElement('div'); d.className='hint'; el.appendChild(d); }); }
function onCellClick(e){
  const S=e.currentTarget.dataset.square, P=game.get(S), own=P&&P.color===game.state().turn;
  if(selected){
    const mv=legal.find(x=>x.to===S);
    if(mv){ game.move({from:selected,to:S,promotion:'q'}); selected=null; legal=[]; clearHL(); render(); return; }
    if(own){ selected=S; legal=game.moves({square:S}); clearHL(); document.querySelector('.cell[data-square="'+S+'"]').classList.add('selected'); hints(); }
    else { selected=null; legal=[]; clearHL(); }
    return;
  }
  if(own){ selected=S; legal=game.moves({square:S}); clearHL(); document.querySelector('.cell[data-square="'+S+'"]').classList.add('selected'); hints(); }
}

// Drag & drop (optional)
let drag={active:false,from:null,ghost:null,moves:[]};
function onDragStart(ev,S){
  ev.preventDefault();
  const piece=game.get(S); if(!piece||piece.color!==game.state().turn) return;
  drag.active=true; drag.from=S; drag.moves=game.moves({square:S});
  clearHL(); document.querySelector('.cell[data-square="'+S+'"]')?.classList.add('selected'); hints();
  const img=ev.currentTarget, g=img.cloneNode(true);
  g.style.position='fixed'; g.style.left='0'; g.style.top='0'; g.style.width='min(12vmin,80px)'; g.style.height='min(12vmin,80px)';
  g.style.pointerEvents='none'; g.style.zIndex='9999'; g.style.transform='translate(-50%,-50%)'; document.body.appendChild(g); drag.ghost=g;
  moveGhost(ev.clientX,ev.clientY); window.addEventListener('pointermove', onDragMove, {passive:false}); window.addEventListener('pointerup', onDragEnd, {passive:false});
}
function moveGhost(x,y){ if(!drag.ghost) return; drag.ghost.style.left=x+'px'; drag.ghost.style.top=y+'px'; }
function onDragMove(ev){ ev.preventDefault(); moveGhost(ev.clientX,ev.clientY); }
function onDragEnd(ev){
  ev.preventDefault(); window.removeEventListener('pointermove', onDragMove); window.removeEventListener('pointerup', onDragEnd);
  if(!drag.active) return;
  const el=document.elementFromPoint(ev.clientX,ev.clientY); const cell=el && el.closest ? el.closest('.cell') : null;
  const to=cell ? cell.dataset.square : null; const m=drag.moves.find(x=>x.to===to);
  if(m){ game.move({from:drag.from,to:to,promotion:'q'}) }
  drag.active=false; drag.from=null; drag.moves=[]; if(drag.ghost&&drag.ghost.parentNode) drag.ghost.parentNode.removeChild(drag.ghost); drag.ghost=null; clearHL(); render();
}

function updateStatus(){
  const st=game.state(); let t=`Au trait : ${st.turn==='w'?'Blancs':'Noirs'}`;
  const L=game.all(); if(L.length===0){ if(game.inCheck(st.turn)) t=`Échec et mat — ${st.turn==='w'?'Noirs':'Blancs'} gagnent`; else t='Pat — partie nulle'; }
  else if(game.inCheck(st.turn)) t+=' — Échec !';
  status.textContent=t;
}

// Controls
document.getElementById('btnNew').addEventListener('click', ()=>{ game.reset(); selected=null; legal=[]; clearHL(); render(); });
document.getElementById('btnFlip').addEventListener('click', ()=>{ orientation=(orientation==='white')?'black':'white'; selected=null; legal=[]; clearHL(); render(); });
btnMode.addEventListener('click', ()=>{ mode=(mode==='click')?'drag':'click'; btnMode.textContent='Mode: '+(mode==='click'?'Clic':'Drag'); render(); });

render();
</script>
</body>
</html>